public:: true
icon:: üõú
inherit-color-icon-from:: [[logseq-page-color-purple]]
tags:: uni
alias:: wave propagation, wellenausbreitungs, wellenausbreitung, WA

- ## vorlesungen
	- ![üìö WA-Skriptum-17.Auflage.pdf](file://C:\Users\Matteo\Documents\Uni\Wellenausbreitung\WA-Skriptum-17.Auflage.pdf)
	- [[wellen vo temp]]
- ## beispiele
	- ![üìö 23_wa_version2.pdf](file://C:\Users\Matteo\Documents\Uni\Wellenausbreitung\23_wa_version2.pdf)
	- ![üìö Formelsammlung_7.Auflage.pdf](C:\Users\Matteo\Downloads\Wellenausbreitung (VU)\Unterlagen\Formelsammlung_7.Auflage.pdf)
	- √úbergang von Vakuum nach Glas
	  background-color:: green
	  collapsed:: true
		- Variante 1) Eine zirkular polarisierte Welle mit einem Querschnitt von $A = \mathrm{3~mm^2}$ und einer Leistung von $P = \mathrm{10~mW}$ wird unter dem Brewster-Winkel auf eine GrenzÔ¨Ç√§che zwischen Vakuum ($n_1 = \mathrm{1}$) und Glas ($n_2 = \mathrm{1.6}$) eingestrahlt.
		  background-color:: green
		  ![img](../assets/Documents/WA_vakuum_glas_bsp.webp)
			- {{evalpage}}
			- a) Berechnen Sie Einfallswinkel $\Theta_e$, ReÔ¨Çexionswinkel $\Theta_r$ und Austrittswinkel $\Theta_t$ und zeichnen Sie diese in die Skizze ein!
			  background-color:: green
			  collapsed:: true
				- formeln
					- $\Theta_i = \Theta_r$
					  tags:: formel
					  bezeichnung:: Reflektions gesetz
						- $\Theta_i$ ... einfallswinkel (***i***nbound) $\mathrm{[¬∞]}$
						- $\Theta_r$ ... reflektionswinkel (***r***eflected) $\mathrm{[¬∞]}$
					- ((6734720f-e42f-46c0-a512-3075ea423042))
					- $\Theta_{b}=\arctan\left(\frac{n_2}{n_1}\right)$
					  tags:: formel
					  bezeichnung:: [[brewster winkel]]
						- $\Theta_b$ ... Brewster winkel $\mathrm{[¬∞]}$
						- $n_1$ ... [[brechungsindex]] $\mathrm{[-]}$
						- $n_2$ ... [[brechungsindex]] $\mathrm{[-]}$
			- b) Berechnen Sie die Querschnitsfl√§che $A$ des transmittierten Strahls!
			  background-color:: green
			  collapsed:: true
				- formeln
					- ((6734720b-5c51-4f95-ac33-ed541e99c1ca))
			- c) Berechnen Sie die Leistungen $P_{\mathrm{TE,t}}$ und $P_{\mathrm{TM,t}}$ der transmittierten Wellen!
			  background-color:: green
			  collapsed:: true
				- formeln
					- ((6735b379-5292-4604-baef-85a4c9a6fc3f))
					- ((6735b379-80fa-4b2a-be2d-af5089fe1fa8))
					- ((6735b379-8ba8-4a90-b5e2-8b5b38036526))
					- ((6735b379-1a1f-417e-8323-7fe94bd9e2cf))
					- $\vect{P}_{\mathrm{t}} = \vect{P}_{\mathrm{TE,t}} + \vect{P}_{\mathrm{TM,t}}$
					  id:: 673b6e21-b584-4162-9dee-58697f01a4bb
					  tags:: formel
					  bezeichnung:: leistung der transmittierten welle
					  collapsed:: true
						- $\vect{P}_{\mathrm{t}}$ ... gesamte leistung der transmittierten Welle $\mathrm{\left[ W \right]}$
						- $\vect{P}_{\mathrm{TE,t}}$ ... leistung der transmittierten TE Welle $\mathrm{\left[ W \right]}$
						- $\vect{P}_{\mathrm{TM,t}}$ ... leistung der transmittierten TM Welle $\mathrm{\left[ W \right]}$
					- ((6735b379-9a02-48b3-997c-2ecd856cb257))
					- ((67360de7-70f6-457a-b7e1-e13b553b5d80))
			- [üìö 2024-11-12 16h29m.xopp](../assets/documents/2024-11-12 16h29m.xopp)
			- ![üìö 2024-11-12 16h29m_annotated.pdf](../assets/documents/2024-11-12 16h29m_annotated.pdf)
		- Variante 2) Eine zirkular polarisierte Welle mit einem Querschnitt von $A = \mathrm{2~mm^2}$ und einer Leistung von $P = \mathrm{1~mW}$ wird unter dem Brewster-Winkel auf eine GrenzÔ¨Ç√§che zwischen Vakuum ($n_1 = \mathrm{1}$) und Glas ($n_2 = \mathrm{1.5}$) eingestrahlt.
		  background-color:: green
		  id:: 673c4ed2-b233-4982-9c12-8768a4de297f
		  ![img](../assets/Documents/WA_vakuum_glas_bsp.webp)
			- {{evalpage}}
			- a) Berechnen Sie Einfallswinkel $\Theta_e$, ReÔ¨Çexionswinkel $\Theta_r$ und Austrittswinkel $\Theta_t$ und zeichnen Sie diese in die Skizze ein!
			  background-color:: green
			  collapsed:: true
				- formeln
					- $\Theta_i = \Theta_r$
					  tags:: formel
					  bezeichnung:: Reflektions gesetz
						- $\Theta_i$ ... einfallswinkel (***i***nbound) $\mathrm{[¬∞]}$
						- $\Theta_r$ ... reflektionswinkel (***r***eflected) $\mathrm{[¬∞]}$
					- ((6734720f-e42f-46c0-a512-3075ea423042))
					- $\Theta_{b}=\arctan\left(\frac{n_2}{n_1}\right)$
					  tags:: formel
					  bezeichnung:: [[brewster winkel]] [link](((6735b379-a4a2-48f4-800f-7b9292b7a3a1)))
						- $\Theta_b$ ... Brewster winkel $\mathrm{[¬∞]}$
						- $n_1$ ... [[brechungsindex]] $\mathrm{[-]}$
						- $n_2$ ... [[brechungsindex]] $\mathrm{[-]}$
			- b) Berechnen Sie die TE und TM-Anteile ($E$ und $H$) der reÔ¨Çektierten und der transmittierten Welle!
			  background-color:: green
			  id:: 673c4ed2-dc05-4f5a-9d66-ba650eefaef8
			  collapsed:: true
				- formeln
				  id:: 673c4ed2-0871-43a6-bce8-22143bd350d7
					- ((6735b379-5292-4604-baef-85a4c9a6fc3f))
					- ((6735b379-80fa-4b2a-be2d-af5089fe1fa8))
					- ((6735b379-8ba8-4a90-b5e2-8b5b38036526))
					- ((6735b379-1a1f-417e-8323-7fe94bd9e2cf))
					- $\Gamma_{TM} = 0$
					  tags:: formel
					  bezeichnung:: reflektionsfaktor wenn einfallswinkel = [[brewster winkel]] [FS](((6735b379-a4a2-48f4-800f-7b9292b7a3a1)))
						- $\Gamma_{TM}$ ... reflektionsfaktor $\mathrm{\left[ - \right]}$
					- ((6735b379-9a02-48b3-997c-2ecd856cb257))
					- $\eta H = E$
					  tags:: formel, wip
					  bezeichnung:: abgeleitet von hier [link](((6735b379-187a-4654-8126-efd8a322477b)))
					  collapsed:: true
						- $\eta$ ... [[wellenwiderstand]] $\mathrm{\left[ \Omega \right]}$
						- $H$ ... magnetsiche feldst√§rke $\mathrm{\left[ \frac{A}{m} \right]}$
						- $E$ ... elektrische feldst√§rke $\mathrm{\left[ \frac{V}{s} \right]}$
					- ((67360de7-70f6-457a-b7e1-e13b553b5d80))
			- c) Berechnen Sie die Elliptizit√§t der reÔ¨Çektierten und der transmittierten Welle in $\mathrm{dB}$!
			  background-color:: green
			  collapsed:: true
				- formeln
					- ((67360dd7-52ba-4a90-a63b-ad4871a896af))
			- [üìö 2024-11-18 17h41m.xopp](../assets/documents/2024-11-18 17h41m.xopp)
			- ![üìö 2024-11-18 17h41m_annotated.pdf](../assets/documents/2024-11-18 17h41m_annotated.pdf)
		- Variante 3) Ein Lichtstrahl der Sonne (unpolarisiert, aber TM, TE gleich stark) f√§llt zu sp√§ter Stunde ($\Theta_e = 75¬∞$) auf einen See ($n_2 = 1.33$). An der glatten WasseroberÔ¨Ç√§che wird er reÔ¨Çektiert. Zwei Fotografen fotograÔ¨Åeren diese Landschaft. Der zweite verwendet ein ideales PolarisationsÔ¨Ålter um die ReÔ¨Çexion der Sonne im Wasser zu unterdr√ºcken.
		  background-color:: green
		  ![img](../assets/documents/WA_vakuum_glas_bsp.webp)
			- {{evalpage}}
			- a) Wie gro√ü ist die (gesamte) reÔ¨Çektierte Lichtleistung im Verh√§ltnis zur eingestrahlten (in $\mathrm{dB}$)? Zeichnen Sie alle verwendeten Winkel ein.
			  background-color:: green
				- formeln
				  collapsed:: true
					- $\Theta_i = \Theta_r$
					  tags:: formel
					  bezeichnung:: Reflektions gesetz
						- $\Theta_i$ ... einfallswinkel (***i***nbound) $\mathrm{[¬∞]}$
						- $\Theta_r$ ... reflektionswinkel (***r***eflected) $\mathrm{[¬∞]}$
					- ((6734720f-e42f-46c0-a512-3075ea423042))
					- ((6735b379-8ba8-4a90-b5e2-8b5b38036526))
					- ((6735b379-5292-4604-baef-85a4c9a6fc3f))
					- ((6735b379-9a02-48b3-997c-2ecd856cb257))
				- code
					- ```python
					  import pyodide_js
					  await pyodide_js.loadPackage("micropip")
					  import micropip
					  await micropip.install('scipy')
					  from scipy import *
					  from scipy.constants import *
					  from numpy import arcsin, arctan, arccos
					  
					  n1 = 1
					  n2 = 1.33
					  n = n2/n1
					  theta1 = 75 * degree
					  theta2 = arcsin(n1/n2 * sin(theta1))
					  "theta2: " + f"{round(theta2 / degree,3)}" +" deg"
					  ```
						- {{evalparent}}
					- ```python
					  gammaTE = (( n1 * cos(theta1) - n2 * cos(theta2) ) /
					             ( n1 * cos(theta1) + n2 * cos(theta2) ))
					  "gammaTE: " + str(gammaTE)
					  ```
						- {{evalparent}}
					- ```python
					  gammaTM = (( n2*cos(theta1)-n1*cos(theta2) ) /
					             ( n2*cos(theta1)+n1*cos(theta2) ))
					  "gammaTM: " + str(gammaTM)
					  ```
						- {{evalparent}}
					- ```python
					  R = round(10 * log10((gammaTE**2+gammaTM**2)/2),3)
					  "R: " + str(R) + " dB"
					  ```
						- {{evalparent}}
			- b) Wie gut kann das ideal eingesetzte PolarisationsÔ¨Ålter des zweiten Fotografen die ReÔ¨Çexion im Vergleich zum ersten Fotografen unterdr√ºcken (in $\mathrm{dB}$)?
			  background-color:: green
				- es geht hierbei darum, dass ein filter verwendet wird welches den TM oder TE anteil filtert
				- code
					- ```python
					  # gammaTM = 0
					  R_TM=round(10 * log10((gammaTE**2)/2),3)
					  "R_TM: " + str(R_TM) + " dB"
					  ```
						- {{evalparent}}
					- ```python
					  # gammaTE = 0
					  R_TE = round(10 * log10((gammaTM**2)/2),3)
					  "R_TE: " + str(R_TE) + " dB"
					  ```
						- {{evalparent}}
					- ```python
					  # R_TE negativer
					  "Photograf2/Photograf1: " + str(R_TE-R) + " dB"
					  ```
						- {{evalparent}}
			- [üìö 2024-11-20 19h04m.xopp](../assets/documents/2024-11-20 19h04m.xopp)
			- ![üìö 2024-11-20 19h04m_annotated.pdf](../assets/documents/2024-11-20 19h04m_annotated.pdf)
	- Stehende Welle im verlustbehafteten Medium
	  background-color:: green
	  collapsed:: true
		- Eine sich im [verlustbehafteten Medium](((6740c4fa-4d26-4310-b196-321b7391feb6))) (z.B.: trockener Erdboden) ausbreitende ebene Welle mit $f = \mathrm{20~MHz}$ wird von einer auf die Ausbreitungsrichtung senkrecht stehenden [metallischen Wand mit unendlicher Leitf√§higkeit](((67405634-4634-4d0d-b586-6a52b1bb7c75))) reÔ¨Çektiert (siehe Abbildung). Die Amplitude der einfallenden Welle bei $z = 0$ betr√§gt $\mathrm{5~V/m}$.
		  background-color:: green
		  Hinweis: $\varepsilon_0 = \mathrm{8,854¬∑ 10^{‚àí12}~As/Vm}$, $¬µ0 = \mathrm{4œÄ ¬∑ 10^{‚àí7}~Vs/Am}$.
		  ![img](../assets/documents/WA_stehende_welle_wand_bsp1.webp)
			- skript
			  collapsed:: true
				- ((67405657-2347-4d8b-93f5-98a6b52c836c))
				  id:: 67405634-4634-4d0d-b586-6a52b1bb7c75
				- ((6740c51b-b09e-4b73-b018-e2d77efe468b))
				  id:: 6740c4fa-4d26-4310-b196-321b7391feb6
			- {{evalpage}}
			- a) Wie gro√ü ist die Phasengeschwindigkeit $v_P$?
			  background-color:: green
				- formeln
					- ((673e3379-4b5b-475a-91a4-08da8e21eb58))
				- code
					- ```python
					  import pyodide_js
					  await pyodide_js.loadPackage("micropip")
					  import micropip
					  await micropip.install('scipy')
					  from scipy import *
					  from scipy.constants import *
					  from numpy import *
					  await micropip.install('matplotlib')
					  import matplotlib.pyplot as plt
					  import io, base64
					  await micropip.install('sympy')
					  import sympy as sp
					  from sympy.utilities.lambdify import lambdify
					  from sympy import latex
					  
					  
					  epsr = 7
					  mur = 1
					  
					  v_p = 1/((epsilon_0 * epsr * mu_0 * mur)**(1/2))
					  "v_p = " + f"{v_p:.4g}" + " m/s"
					  ```
						- {{evalparent}}
			- b) Setzten Sie die einfallende Welle an ($E_e$ und $H_e$) und berechnen Sie die Wellenzahl $k_e$. Wie gro√ü ist die D√§mpfung in $\mathrm{dB/m}$
			  background-color:: green
				- formeln
					- ((67404a07-268a-4632-b86f-c136cdfaf0eb))
					- ((673e3379-7ae8-425b-bf90-a176d50f983b))
					- ((673e3379-65ec-4bba-988b-f6a5d8499e68)) [FS](((6745a2d1-96eb-4141-93fd-4c8e10df8d94)))
					- ((674496c6-ef08-4cfe-8444-ef86aadf0f47)) [FS](((6740c68b-e124-4f93-b1f1-9c8be879951c)))
					- ((67459ac7-d3b4-47bf-9ac5-0379a5e2e1e8)) [FS](((673e3379-64cb-4d50-98c9-668f6b9fd3fd)))
				- code
					- ```python
					  mu = mur * mu_0
					  eps = epsr * epsilon_0
					  f = 20E6
					  w = 2 * pi * f
					  ke = w * sqrt(mu * eps)
					  "ke = " + f"{ke:.4g}" + "rad/m"
					  ```
						- {{evalparent}}
					- ```python
					  # bei z = 0
					  E0 = 5
					  sig = 1.5e-3
					  alpha = 0
					  
					  s = sig / (eps * w)
					  jke=1j*ke*sqrt(1-1j*s)
					  alpha = real(jke)
					  beta = imag(jke)
					  
					  "Œ± = " + f"{alpha:.4g}" + " rad/m \n\
					  Œ≤ = " + f"{beta:.4g}" + " rad/m"
					  ```
						- {{evalparent}}
					- ```python
					  D = 20 * log10(E0 / (E0 * e**-alpha))
					  
					  "D = " + f"{D:.4g}" + " dB"
					  ```
						- {{evalparent}}
						- ich wei√ü leider nicht warum man genau die D√§mpfung so ausrechnet und warum man genau $\alpha$ verwendet #wip
			- c) Berechnen Sie die komplexe Amplitude und den zeitlichen Verlauf der einfallenden Welle am Ort der metallischen Wand $z_0 = \mathrm{8~m}$!
			  background-color:: green
				- formeln
					- ((673e3379-7ae8-425b-bf90-a176d50f983b))
					- ((673e3379-9e8e-4059-b99e-e764c678fa51))
					- ((673e3379-54d5-49f8-b0db-18b82bf799c4))
				- code
					- ```python
					  z0 = 8
					  z = z0
					  Ee = E0 * e**(-jke*z)
					  "Ee(z=8) = " + f"{Ee:.4g}" + " V/m \n\
					  abs(Ee) = " + f"{abs(Ee):.4g}" + " V/m"
					  ```
						- {{evalparent}}
					- ```python
					  T = 1/f
					  print(T)
					  t = linspace(0, 2*T , 500)  # Generate 500 points between 0 and 4œÄ
					  y = E0*e**(-alpha*z0)*cos(w*t-beta*z0)
					  
					  # Create the plot
					  plt.clf()
					  plt.plot(t, y)  # Plot y = sin(x)
					  plt.xlabel('t')  # Label the x-axis
					  plt.ylabel('E_e(z_0, t)')  # Label the y-axis
					  plt.grid(True)  # Add a grid
					  buf = io.BytesIO()
					  plt.savefig(buf, format = 'png')
					  buf.seek(0)
					  png = 'data:image/png;base64,' + base64.b64encode(buf.read()).decode('UTF-8')
					  buf.close()
					  png
					  ```
						- {{evalparent}}
			- d) Finden Sie einen Ansatz f√ºr die reÔ¨Çektierte Welle ($E_r$ und $H_r$)! Wie muss der zeitliche Verlauf der reÔ¨Çektierten Welle aussehen, damit die Randbedingungen erf√ºllt sind?
			  background-color:: green
				- formeln
					- ((67459ac8-e918-4a08-8003-07057ff681d6))
					- ((6745a3c5-baa9-4655-ac6f-92348bdacfc0))
					- $E_{r}=Ae^{jk_{z}\left(z_0-z\right)}$
					  tags:: formel
					  bezeichnung:: ansatz f√ºr die reflektierte/r√ºcklaufende welle
						- $E_r$ ... reflektierte/r√ºcklaufende welle des [[elektrischen feldes]] $\mathrm{\left[ \frac{V}{m} \right]}$
						- $A$ ... anfangs amplitude der reflektierten welle. entspricht der einfallenden welle $\mathrm{\left[ \frac{V}{m} \right]}$
						- $k_z$ ... [[komplexe]] [[wellenzahl]] $\mathrm{\left[ \frac{rad}{m} \right]}$
						- $z$ ... entfernung in ausbreitungsrichtung (hier $z$-Achse) $\mathrm{\left[ m \right]}$
						- $z_0$ ... entfernung zur stelle an der die reflexion stattfindet $\mathrm{\left[ m \right]}$
				- code
					- ```python
					  t = sp.symbols('t')
					  z = sp.symbols('z', real=True)
					  z0 = 8
					  
					  # Expression
					  # gesamt feld momentanwert
					  eges = E0 * sp.exp(-alpha * z0) * sp.cos(w * t - beta * z0) * (1 - sp.exp(-alpha * (z0 - z)) * sp.cos(w * t - beta * (z0 - z)))
					  eges = eges.subs(z, z0)
					  # einfallendes feld momentanwert
					  ee = E0 * sp.exp(-alpha * z0) * sp.cos(w * t - beta * z0)
					  ee = ee.subs(z,z0)
					  # reflektiertes feld momentanwert
					  er = -E0 * sp.exp(-alpha * z0) * sp.cos(w * t - beta * z0) * sp.exp(-alpha * (z0 - z)) * sp.cos(w * t - beta * (z0 - z))
					  er = er.subs(z,z0)
					  
					  # Convert to numerical function
					  numerical_eges = lambdify(t, eges)
					  numerical_ee = lambdify(t, ee)
					  numerical_er = lambdify(t, er)
					  
					  # Numerical plotting
					  T=1/f
					  t_vals = linspace(-T+8, 8, 500)
					  
					  plt.clf()
					  y_vals = numerical_eges(t_vals)
					  plt.plot(t_vals, y_vals, label='eges')
					  y_vals = numerical_ee(t_vals)
					  plt.plot(t_vals, y_vals, label='ee')
					  y_vals = numerical_er(t_vals)
					  plt.plot(t_vals, y_vals, label='er')
					  
					  plt.xlabel("t")
					  plt.grid(True)
					  plt.legend()
					  buf = io.BytesIO()
					  plt.savefig(buf, format = 'png')
					  buf.seek(0)
					  png = 'data:image/png;base64,' + base64.b64encode(buf.read()).decode('UTF-8')
					  buf.close()
					  png
					  ```
						- {{evalparent}}
				- verstehe das beispiel nicht. da ist was an der reflektierten welle falsch
			- e) Berechnen Sie die H√ºllkurve des Gesamtfeldes
			  background-color:: green
				- formeln
					- $|E_{ges}|^2 = \vect{E}(z) \cdot \vect{E}^*(z)$
					  tags:: formel
					  bezeichnung:: analyse der h√ºllkurve des [elektrischen gesamtfeldes]([[elektrisches feld]])
						- $|E_{ges}|^2$ ... betrags quadrat des gesamten [[elektrischen feldes]] $\mathrm{\left[ \frac{V}{m} \right]}$
						- $\vect{E}(z)$ ... [[komplexe]] amplitude des [[elektrischen feldes]] $\mathrm{\left[ \frac{V}{m} \right]}$
				- code
					- meine l√∂sung
						- ```python
						  # meine l√∂sung
						  # symbolic math
						  E_s = sp.symbols('E')
						  E0_s = sp.symbols('E0', positive = True)
						  a_s = sp.symbols('Œ±', real = True)
						  b_s = sp.symbols('Œ≤', real = True)
						  z_s = sp.symbols('z', real = True)
						  z0_s = sp.symbols('z0', real = True)
						  jke_s = a_s + 1j * b_s
						  
						  E_s = E0_s * (sp.exp(-jke_s*z_s) \
						            -sp.exp(-jke_s*(z0_s-z_s)))
						  Eabs_s = sp.simplify(sp.conjugate(E_s)*E_s)
						  'E = ' + str(Eabs_s) + '\n\n\
						  latex output: ' + latex(Eabs_s)
						  ```
							- {{evalparent}}
							- $E_{0}^{2} \cdot \left(1 - e^{\left(2 z - z_{0}\right) \left(Œ± - 1.0 i Œ≤\right)}\right) \left(1 - e^{\left(2 z - z_{0}\right) \left(Œ± + 1.0 i Œ≤\right)}\right) e^{- 2 z Œ±}$
						- ```python
						  # plot
						  # bei z = z0
						  lam = 2*pi / ke
						  z = linspace(-4*lam+z0,z0, 1000)
						  
						  E = E0 * e**(-jke*z0)*(1 - e**(-jke*(z0-z)))
						  absE2 = E*conj(E)
						  
						  y = absE2
						  
						  # Create the plot
						  plt.clf()
						  plt.plot(z, y)
						  plt.plot(z, -y)
						  plt.xlabel('z') 
						  plt.ylabel('E')
						  plt.grid(True)
						  buf = io.BytesIO()
						  plt.savefig(buf, format = 'png')
						  buf.seek(0)
						  png = 'data:image/png;base64,' + base64.b64encode(buf.read()).decode('UTF-8')
						  buf.close()
						  png
						  ```
							- {{evalparent}}
					- ausarbeitung
						- ```python
						  # l√∂sung aus ausarbeitung
						  Eabs_s  =E0_s**2 * (sp.exp(-2 * a_s * z_s) + \
						                      sp.exp(-2 * a_s * (z0_s - z_s)) - \
						                      2 * sp.exp(-2 * a_s * z0_s) * sp.cos(2*b_s*(z0_s-z_s)))
						  'E = ' + str(Eabs_s) + '\n\n\
						  latex output: ' + latex(Eabs_s)
						  ```
							- {{evalparent}}
							- $E_{0}^{2} \left(e^{- 2 Œ± \left(- z + z_{0}\right)} - 2 e^{- 2 z_{0} Œ±} \cos{\left(2 Œ≤ \left(- z + z_{0}\right) \right)} + e^{- 2 z Œ±}\right)$
						- ```python
						  # plot
						  # bei z = z0
						  lam = 2*pi / ke
						  z = linspace(-4*lam+z0,z0, 1000)
						  
						  absE2  =E0**2 * (exp(-2 * alpha * z) + \
						                     exp(-2 * alpha * (z0 - z)) - \
						                      2 * exp(-2 * alpha * z0) * cos(2*beta*(z0-z)))
						  y = absE2
						  
						  # Create the plot
						  plt.clf()
						  plt.plot(z, y)
						  plt.plot(z, -y)
						  plt.xlabel('z') 
						  plt.ylabel('E')
						  plt.grid(True)
						  buf = io.BytesIO()
						  plt.savefig(buf, format = 'png')
						  buf.seek(0)
						  png = 'data:image/png;base64,' + base64.b64encode(buf.read()).decode('UTF-8')
						  buf.close()
						  png
						  ```
							- {{evalparent}}
			- [üìö 2024-11-21 18h45m.xopp](../assets/documents/2024-11-21 18h45m.xopp)
			- ![üìö 2024-11-21 18h45m_annotated.pdf](../assets/documents/2024-11-21 18h45m_annotated.pdf)
	- Rechteckhohlleiter
	  background-color:: green
	  collapsed:: true
		- Variante 1) Untersuchen Sie die Ausbreitung von $\mathrm{TE}_{m,n}$ Wellen in $z$ Richtung im skizzierten Rechteckhohlleiter.
		  background-color:: green
		  collapsed:: true
		  ![img](../assets/documents/WA_rechteckhohlleiter_bsp_1.webp)
			- Finden Sie einen geeigneten Ansatz f√ºr die Komponenten der gew√ºnschten Moden in Ausbreitungsrichtung, der die Wellengleichung erf√ºllt. Ermitteln Sie die Separationsbedingungen.
			  background-color:: green
				- formeln
					-
				- code
			- Leiten Sie daraus die restlichen Feldkomponenten her und passen Sie an den Rand an! Welche Komponenten verschwinden?
			  background-color:: green
			- Berechnen Sie die Hohlleiterwellenl√§ngen, die Grenzwellenl√§ngen und die Grenzfrequenzen aller gefragter Moden als Funktion von $m$ und $n$! Ist ein TEM Modus ausbreitungsf√§hig? Wieso? Wenn ja, welche Grenzwellenl√§nge bzw. Feldwellenwiderstand hat er?
			  background-color:: green
			- Berechnen und skizzieren Sie das Dispersionsdiagramm f√ºr die $\mathrm{TE}_{10}$, $\mathrm{TE}_{11}$, $\mathrm{TE}_{20}$ Moden f√ºr $a = 4 \mathrm{cm}$, $b = 3\mathrm{cm}$, $\varepsilon_r = 3$, $\mu_r = 1$, $\varepsilon_0 = 8,854 \cdot 10^{‚àí12} \mathrm{As/Vm}$, $\mu_0 = 4\pi \cdot 10^{‚àí7} \mathrm{Vs/Am}$. Achten Sie auf die Beschriftung! Geben Sie die Grenzfrequenzen an! In welchem Frequenzbereich ist nur ein einziger Modus ausbreitungsf√§hig? Welcher?
			  background-color:: green
		- Variante 2)
		  background-color:: green
		- Variante 3)
		  background-color:: green
		- Variante 4)
		  background-color:: green
	- Hohlraumresonator
	  background-color:: green
	  collapsed:: true
		- Variante 1) Berechnen Sie den Grundmodus $\mathrm{TE_{101}}$ eines luftgef√ºllten ($\varepsilon_r = 1$) Hohlraumresonators (Abmessungen: $a = 4\mathrm{cm}$, $b = 2\mathrm{cm}$, $c = 4\mathrm{cm}$) mit $\mathbb{R}_M = 20\mathrm{m\Omega}$.
		  background-color:: green
		  ![img](../assets/documents/Wa_hohlraumresonator_bsp_1.webp)
			- a) Berechnen Sie die Resonanzfrequenz!
			  background-color:: green
				- formeln
					- ((6745a3c5-c443-4fb4-bbea-b455958f827a))
					- ((673e3379-4b5b-475a-91a4-08da8e21eb58))
					- ((674b703d-c8a8-4814-8c70-f8289a9b6bdf))
				- code
					- ```python
					  import pyodide_js
					  await pyodide_js.loadPackage("micropip")
					  import micropip
					  await micropip.install('scipy')
					  from scipy import *
					  from scipy.constants import *
					  from numpy import *
					  await micropip.install('matplotlib')
					  import matplotlib.pyplot as plt
					  import io, base64
					  await micropip.install('sympy')
					  import sympy as sp
					  from sympy.utilities.lambdify import lambdify
					  from sympy import latex
					  
					  # angabe
					  a = 4E-2
					  b = 2E-2
					  c = 4E-2
					  mur = 1
					  mu = mu_0 * mur
					  epsr = 1
					  eps = epsilon_0 * epsr
					  Rm = 20E-3
					  # TE_101
					  m = 1
					  n = 0
					  p = 1
					  
					  # rechnung
					  vp = 1 / sqrt((eps * mu))
					  wmnp = pi * vp * sqrt((m/a)**2 + (n/b)**2 + (p/c)**2)
					  fmnp = wmnp / (2 * pi)
					  "fmnp = " + f"{fmnp:.4g}" + "Hz"
					  ```
						- {{evalparent}}
			- b) Berechnen Sie die unbelastetet G√ºte! Vereinfachen Sie zuerst die Formel unter der Ber√ºcksichtigung $a = c$! Setzen Sie dann Zahlenwerte ein!
			  background-color:: green
				- formeln
					- ((6745a3c5-66f7-450b-94fe-f6068dde589d))
				- code
					- ```python
					  Rm_s, a_s, b_s, c_s, eta_s = sp.symbols('R_m a b c eta', 
					                                          real=True, 
					                                          positive=True)
					  eta = 377
					  Q0 = (
					    (pi * eta) / (2 * Rm) * 
					      (
					        (b * sqrt((a**2 + c**2)**3)) / 
					        (a * c * (a**2 + c**2) + 2 * b * (a**3 + c**3))
					      )
					  )
					  
					  Q0_s = (
					    (sp.pi * eta_s) / (2 * Rm_s) *
					    (
					      b_s * sp.sqrt((a_s**2 + c_s**2)**3) /
					      (a_s * c_s * (a_s**2 + c_s**2) + 2 * b_s * (a_s**3 + c_s**3))
					    )
					  )
					  Q0_s_sim = Q0_s.subs(c_s, a_s)
					           
					  Q0_s_sim = sp.simplify(Q0_s_sim)
					  'Q0_s = ' + str(Q0_s) + '\n\n\
					  latex output: ' + latex(Q0_s) + '\n\n\
					  Q0_s_sim = ' + str(Q0_s_sim) + '\n\n\
					  latex output: ' + latex(Q0_s_sim)
					  ```
						- {{evalparent}}
						- $\frac{\pi b \eta \left(a^{2} + c^{2}\right)^{\frac{3}{2}}}{2 Rm \left(a c \left(a^{2} + c^{2}\right) + 2 b \left(a^{3} + c^{3}\right)\right)}$
						- $\frac{\sqrt{2} \pi b \eta}{2 R_{m} \left(a + 2 b\right)}$
					- ```python
					  Q0_s_sim.subs(a_s, a).subs(b_s,b).subs(Rm_s, Rm).subs(eta_s, eta).evalf(n=5)
					  ```
						- {{evalparent}}
			- c) Berechnen Sie die Resonanzfrequenz und die unbelastete G√ºte, wenn der Hohlraumresonator mit einem verlustlosen Dielektrikum $\varepsilon_r = 2.5$ gef√ºllt ist!
			  background-color:: green
				- formeln
					- ((6745a3c5-c443-4fb4-bbea-b455958f827a))
					- ((6745a3c5-66f7-450b-94fe-f6068dde589d))
					- ((673c4eb2-5827-434c-a323-0ff29f347504))
				- code
					- ```python
					  # resonanzfrequenz
					  epsr = 2.5
					  eps = epsilon_0 * epsr
					  
					  # rechnung
					  vp = 1 / sqrt((eps * mu))
					  wmnp = pi * vp * sqrt((m/a)**2 + (n/b)**2 + (p/c)**2)
					  fmnp = wmnp / (2 * pi)
					  "fmnp = " + f"{fmnp:.4g}" + "Hz"
					  ```
						- {{evalparent}}
					- ```python
					  # unbelastete g√ºte
					  eta = sqrt(mu/eps)
					  Q0 = (
					    (pi * eta) / (2 * Rm) * 
					      (
					        (b * sqrt((a**2 + c**2)**3)) / 
					        (a * c * (a**2 + c**2) + 2 * b * (a**3 + c**3))
					      )
					  )
					  "Q0 = " + f"{Q0:.4g}"
					  ```
						- {{evalparent}}
		- Variante 2) Berechnen Sie den Grundmodus $\mathrm{TE_{101}}$ eines luftgef√ºllten ($\varepsilon_r = 1$) Hohlraumresonators (Abmessungen: $a = 2b=c$, $\mathbb{R}_M = 30\mathrm{m\Omega}$).
		  background-color:: green
		  ![img](../assets/documents/Wa_hohlraumresonator_bsp_1.webp)
			- a) Berechnen Sie die Abmessungen $a, b, c$ f√ºr eine Resonanzfrequenz von $20 \mathrm{GHz}$!
			  background-color:: green
				- formeln
					- ((6745a3c5-c443-4fb4-bbea-b455958f827a))
					- ((673e3379-4b5b-475a-91a4-08da8e21eb58))
					- ((674b703d-c8a8-4814-8c70-f8289a9b6bdf))
				- code
					- ```python
					  pyodide_js.globals.clear();
					  import pyodide_js
					  await pyodide_js.loadPackage("micropip")
					  import micropip
					  await micropip.install('scipy')
					  from scipy import *
					  from scipy.constants import *
					  from numpy import *
					  await micropip.install('matplotlib')
					  import matplotlib.pyplot as plt
					  import io, base64
					  await micropip.install('sympy')
					  import sympy as sp
					  from sympy.utilities.lambdify import lambdify
					  from sympy import latex
					  
					  # angabe
					  mur = 1
					  mu = mu_0 * mur
					  epsr = 1
					  eps = epsilon_0 * epsr
					  Rm = 30E-3
					  fR = 20E9
					  wmnp = 2 * pi * fR
					  # TE_101
					  m = 1
					  n = 0
					  p = 1
					  
					  Rm_s, a_s, b_s, c_s, vp_s ,m_s, n_s, p_s = sp.symbols('R_m a b c v_p m n p', 
					                                                       real=True, 
					                                                       positive=True)
					  
					  # rechnung
					  vp = 1 / sqrt((eps * mu))
					  wmnp_s = ( sp.pi * vp_s * sp.sqrt(
					              (m_s/a_s)**2 + (n_s/b_s)**2 + (p_s/c_s)**2
					             )
					           )
					  fmnp_s = wmnp_s / (2 * sp.pi)
					  
					  # werte einsetzen
					  fmnp_s = (fmnp_s.subs(m_s,m)
					                  .subs(n_s,n)
					            	    .subs(p_s,p)
					            	    .subs(c_s,a_s)
					           		.subs(b_s,a_s/2)
					           		.subs(vp_s, vp))
					  eqn = sp.Eq(fmnp_s,fR)
					  solution = sp.solve(eqn, a_s)
					  a = float(solution[0])
					  b = a/2
					  c = a
					  ("a = " + f"{a*100:.4g}" + "cm" + "\n" + 
					   "b = " + f"{b*100:.4g}" + "cm" + "\n" + 
					   "c = " + f"{c*100:.4g}" + "cm"
					  )
					  ```
						- {{evalparent}}
			- b) Berechnen Sie die unbelastetet G√ºte! Vereinfachen Sie zuerst die Formel unter der Ber√ºcksichtigung $a = 2b = c$!
			  background-color:: green
				- formeln
					- ((6745a3c5-66f7-450b-94fe-f6068dde589d))
				- code
					- ```python
					  eta_s = sp.symbols('eta', real=True, positive=True)
					  Q0_s = (
					    (sp.pi * eta_s) / (2 * Rm_s) *
					    (
					      b_s * sp.sqrt((a_s**2 + c_s**2)**3) /
					      (a_s * c_s * (a_s**2 + c_s**2) + 2 * b_s * (a_s**3 + c_s**3))
					    )
					  )
					  Q0_s_sim = Q0_s.subs(c_s, a_s).subs(b_s, a_s/2)
					           
					  Q0_s_sim = sp.simplify(Q0_s_sim)
					  'Q0_s = ' + str(Q0_s) + '\n\n\
					  latex output: \n' + latex(Q0_s) + '\n\n\
					  Q0_s_sim = ' + str(Q0_s_sim) + '\n\n\
					  latex output: \n' + latex(Q0_s_sim)
					  ```
						- {{evalparent}}
						- $\frac{\pi b \eta \left(a^{2} + c^{2}\right)^{\frac{3}{2}}}{2 Rm \left(a c \left(a^{2} + c^{2}\right) + 2 b \left(a^{3} + c^{3}\right)\right)}$
						- $\frac{\sqrt{2} \pi \eta}{8 R_{m}}$
					- ```python
					  eta = sqrt(mu/eps)
					  Q0_s_sim.subs(a_s, a).subs(b_s,b).subs(Rm_s, Rm).subs(eta_s, eta).evalf(n=5)
					  ```
						- {{evalparent}}
			- c) Berechnen Sie die relative Dielektrizit√§tskonstante und die unbelastete [[G√ºte]], wenn der Hohlraumresonator mit einem verlustlosen Dielektrikum gef√ºllt ist, um die Resonanzfrequenz auf $15 \mathrm{GHz}$ zu reduzieren!
			  background-color:: green
				- formeln
					- ((6745a3c5-c443-4fb4-bbea-b455958f827a))
					- ((6745a3c5-66f7-450b-94fe-f6068dde589d))
					- ((673c4eb2-5827-434c-a323-0ff29f347504))
				- code
					- ```python
					  # dielektrizit√§tskonstante
					  fR = 15E9
					  
					  epsr_s = sp.symbols('eps_r', real=True, positive=True)
					  eps_s = epsr_s * epsilon_0
					  vp_s = 1 / sp.sqrt((eps_s * mu))
					  wmnp_s = ( sp.pi * vp_s * sp.sqrt(
					              (m_s/a_s)**2 + (n_s/b_s)**2 + (p_s/c_s)**2
					             )
					           )
					  fmnp_s = wmnp_s / (2 * sp.pi)
					  
					  # werte einsetzen
					  fmnp_s = (fmnp_s.subs(m_s,m)
					                  .subs(n_s,n)
					            	    .subs(p_s,p)
					            		.subs(a_s,a)
					            	    .subs(c_s,c)
					           		.subs(b_s,b))
					  eqn = sp.Eq(fmnp_s,fR)
					  solution = sp.solve(eqn, epsr_s)
					  epsr = float(solution[0])
					  
					  "…õ_r = " + f"{epsr:.4g}"
					  ```
						- {{evalparent}}
					- ```python
					  # unbelastete g√ºte
					  eps = epsr * epsilon_0
					  eta = sqrt(mu/eps)
					  Q0 = (
					    (pi * eta) / (2 * Rm) * 
					      (
					        (b * sqrt((a**2 + c**2)**3)) / 
					        (a * c * (a**2 + c**2) + 2 * b * (a**3 + c**3))
					      )
					  )
					  "Q0 = " + f"{Q0:.4g}"
					  ```
						- {{evalparent}}
			- [üìö 2024-12-01 16h11m.xopp](../assets/documents/2024-12-01 16h11m.xopp)
			- ![üìö 2024-12-01 16h11m_annotated.pdf](../assets/documents/2024-12-01 16h11m_annotated.pdf)
	- [[Koaxialkabel]]
	  background-color:: green
	  collapsed:: true
		- Variante 1)
		  background-color:: green
		  ![img](../assets/documents/WA_koaxialkabel_bsp_1.webp)
			- a) Bestimmen Sie einen geeigneten Innenradius $r_i$ des abgebildeten Koaxialkabels f√ºr $Z_L = 60 \mathrm{\Omega}$. Der Au√üenradius sei $r_a = 8.5 \mathrm{mm}$, das verwendete Dielektrikum sei Luft mit $\varepsilon_r = 1$.
			  background-color:: green
				- formeln
					- ((6745a3c5-c563-4874-8d5b-50fee6812aea))
				- code
					- ```python
					  pyodide_js.globals.clear();
					  ```
						- {{evalparent}}
					- ```python
					  import pyodide_js
					  await pyodide_js.loadPackage("micropip")
					  import micropip
					  await micropip.install('scipy')
					  from scipy import *
					  from scipy.constants import *
					  from numpy import *
					  await micropip.install('matplotlib')
					  import matplotlib.pyplot as plt
					  import io, base64, sys
					  await micropip.install('sympy')
					  import sympy as sp
					  from sympy.utilities.lambdify import lambdify
					  from sympy import latex
					  printer = io.StringIO()
					  sys.stdout = printer
					  
					  # angabe
					  ZL = 60
					  ra = 8.5E-3
					  epsr = 1
					  eps = epsr * epsilon_0
					  mur = 1
					  mu = mur * mu_0
					  eta = sqrt(mu/eps)
					  
					  eta_s, ra_s, ri_s = sp.symbols('eta r_a r_i', 
					                                 real=True, 
					                                 positive=True)
					  ZL_s = eta_s/(2*pi) * sp.ln(ra_s / ri_s)
					  
					  eqn = sp.Eq(ZL_s, ZL)
					  sol = sp.solve(eqn, ri_s)
					  ri_s = sol[0]
					  
					  # werte einsetzen
					  ri = (ri_s.subs(ra_s, ra)
					          	.subs(eta_s, eta)).evalf(n=4)
					  
					  print(f"r_i = {ri*1000:.4g}mm")
					  print("‚Äæ‚Äæ‚Äæ‚Äæ‚Äæ‚Äæ‚Äæ‚Äæ‚Äæ‚Äæ‚Äæ‚Äæ‚Äæ")
					  print(f"latex output: {latex(ri_s)}")
					  sp.pprint(ri_s,use_unicode=False)
					  
					  printer.getvalue()
					  ```
						- {{evalparent}}
						- $r_{a} e^{- \frac{376.991118430776}{\eta}}$
			- b) Die Innen- bzw. Au√üenleiter bestehen aus Kupfer mit $\sigma = 57 \cdot 10^6 \mathrm{S/m}$. Wie gro√ü ist die Eindringtiefe bei $f = 5 \mathrm{GHz}$? Berechnen Sie die ohmschen Verluste des Kabels in $\mathrm{dB/m}$.
			  background-color:: green
				- formeln
					- ((674d7759-c315-4a22-a755-be7a35c4b441))
					- ((674d7759-1d40-46b8-9d39-cbf868cd298e))
					- ((674d7759-4a7e-4220-b396-27bd49ccaa45))
					- ((674de501-a2a9-4e7a-8a81-892354262c7e))
				- code
					- ```python
					  printer.seek(0); printer.truncate(0)
					  sig = 57E6
					  f = 5E9
					  w = 2*pi*f
					  d = sqrt(2/(w*mu*sig))
					  print(f"d = {d*1E9:.4g}nm")
					  printer.getvalue()
					  ```
						- {{evalparent}}
					- ```python
					  printer.seek(0); printer.truncate(0)
					  R = (sqrt((w * mu)/(2 * sig))*
					       1 / (2 * pi) * (1 / ri + 1 / ra))
					  
					  alphaR = R/(2*ZL)
					  print(f"Œ±R = {alphaR:.4g}Np/m")
					  print(f"Œ±R = {alphaR*20/log(10):.4g}dB/m")
					  printer.getvalue()
					  ```
						- {{evalparent}}
			- c) Ein Ende der Koaxialleitung wird mit Hilfe einer kreisf√∂rmigen Scheibe aus Graphit abgeschlossen. Die Scheibe habe ein $R_\square  = 120\pi \mathrm{\Omega}$. Welchen ohmschen Widerstand hat die kreisf√∂rmige Scheibe f√ºr eine einfallende $\mathrm{TEM}$ Welle?
			  background-color:: green
				- ![img](../assets/documents/WA_koaxleitung_abschluss_illustration.webp)
				- formeln
					- ((674d7759-2399-4628-94f1-400ee5be7c0e))
				- code
					- ```python
					  printer.seek(0); printer.truncate(0)
					  Rsq = 120*pi
					  r_s = sp.symbols('r', positive=True, real=True)
					  R = sp.integrate(Rsq/(2*pi*r_s), (r_s,ri,ra))
					  print(f"R = {R:.4g}Œ©")
					  printer.getvalue()
					  ```
						- {{evalparent}}
			- d) Wie gro√ü ist der ReÔ¨Çexionsfaktor am Ende der Koaxialleitung auf Grund des Abschlusswidertandes der kreisf√∂rmigen Scheibe? In welchem Frequenzbereich gilt dieser ReÔ¨Çexionsfaktor?
			  background-color:: green
				- formeln
					- $\rho_{A} = \frac{R_{A}-Z_{L}}{R_{A}+Z_{L}}$
					  tags:: formel
					  bezeichnung:: reflexionsfaktor am ende einer [[koaxialleitung]]
						- $R_A$ ... Abschlusswiderstrand $\mathrm{\left[\Omega\right]}$
						- $Z_L$ ... leitungsimpedanz $\mathrm{\left[\Omega\right]}$
						- skript
						  collapsed:: true
							- ((674ec847-fd7d-4084-915e-8421e8671ad5))
				- code
					- ```python
					  printer.seek(0); printer.truncate(0)
					  RA = R # wert der vorher berechnet wurde
					  rA = (RA-ZL)/(RA+ZL)
					  print(f"r = {rA*1E4:.4g}e-4")
					  printer.getvalue()
					  ```
						- {{evalparent}}
						- es ist schwierig den frequenzbereich abzusch√§tzen, da $R_A$ und $Z_L$ von der frequenz abh√§ngen
		- Variante 2)
		  background-color:: green
		  ![img](../assets/documents/WA_koaxialkabel_bsp_1.webp)
			- a) Bestimmen Sie einen geeigneten Innenradius $r_i$ des abgebildeten Koaxialkabels f√ºr $Z_L = 50 \mathrm{\Omega}$. Der Au√üenradius sei $r_a = 7.3 \mathrm{mm}$, das verwendete Dielektrikum sei Luft mit $\varepsilon_r = 2.35$.
			  background-color:: green
				- formeln
					- ((6745a3c5-c563-4874-8d5b-50fee6812aea))
				- code
					- ```python
					  pyodide_js.globals.clear();
					  ```
						- {{evalparent}}
					- ```python
					  import pyodide_js
					  await pyodide_js.loadPackage("micropip")
					  import micropip
					  await micropip.install('scipy')
					  from scipy import *
					  from scipy.constants import *
					  from numpy import *
					  await micropip.install('matplotlib')
					  import matplotlib.pyplot as plt
					  import io, base64, sys
					  await micropip.install('sympy')
					  import sympy as sp
					  from sympy.utilities.lambdify import lambdify
					  printer = io.StringIO()
					  sys.stdout = printer
					  
					  # angabe
					  ZL = 50
					  ra = 7.3E-3
					  epsr = 2.35
					  eps = epsr * epsilon_0
					  mur = 1
					  mu = mur * mu_0
					  eta = sqrt(mu/eps)
					  
					  eta_s, ra_s, ri_s = sp.symbols('eta r_a r_i', 
					                                 real=True, 
					                                 positive=True)
					  ZL_s = eta_s/(2*pi) * sp.ln(ra_s / ri_s)
					  
					  eqn = sp.Eq(ZL_s, ZL)
					  sol = sp.solve(eqn, ri_s)
					  ri_s = sol[0]
					  
					  # werte einsetzen
					  ri = (ri_s.subs(ra_s, ra)
					          	.subs(eta_s, eta)).evalf(n=4)
					  
					  print(f"r_i = {ri*1000:.4g}mm")
					  print("‚Äæ‚Äæ‚Äæ‚Äæ‚Äæ‚Äæ‚Äæ‚Äæ‚Äæ‚Äæ‚Äæ‚Äæ‚Äæ")
					  print(f"latex code: {sp.latex(ri_s)}")
					  sp.pprint(ri_s,use_unicode=False)
					  
					  printer.getvalue()
					  ```
						- {{evalparent}}
						- $r_{a} e^{- \frac{314.15926535898}{\eta}}$
			- b) Berechnen Sie die ohmschen Verluste $\alpha_R$ des Kabels f√ºr eine Leitf√§higkeit des Innen- bzw. Au√üenleiters von $\sigma=5.7\cdot10^7\mathrm{S/m}$ bei $8\mathrm{GHz}$ in $\mathrm{dB/m}$.
			  background-color:: green
				- formeln
					- ((674d7759-1d40-46b8-9d39-cbf868cd298e))
					- ((674d7759-4a7e-4220-b396-27bd49ccaa45))
					- ((674de501-a2a9-4e7a-8a81-892354262c7e))
				- code
					- ```python
					  printer.seek(0); printer.truncate(0)
					  sig = 57E6
					  f = 8E9
					  w = 2*pi*f
					  R = (sqrt((w * mu)/(2 * sig))*
					       1 / (2 * pi) * (1 / ri + 1 / ra))
					  print(f"R' = {R:.4g}Œ©/m")
					  
					  alphaR = R/(2*ZL)
					  print(f"alphaR = {alphaR:.4g}Np/m")
					  print(f"alphaR = {alphaR*20/log(10):.4g}dB/m")
					  print("‚Äæ‚Äæ‚Äæ‚Äæ‚Äæ‚Äæ‚Äæ‚Äæ‚Äæ‚Äæ‚Äæ‚Äæ‚Äæ‚Äæ‚Äæ‚Äæ‚Äæ‚Äæ‚Äæ‚Äæ")
					  
					  printer.getvalue()
					  ```
						- {{evalparent}}
			- c) Berechnen Sie die dielektrischen Verluste $\alpha_G$ des Kabels f√ºr ein Dielektrikum mit $\tan\delta = 0.001 \mathrm{dB/m}$ in $\mathrm{dB/m}$.
			  background-color:: green
				- formeln
					- ((674d7759-056e-4bac-998e-f2bccdc83035))
				- code
					- ```python
					  printer.seek(0); printer.truncate(0)
					  
					  tand= 0.001
					  
					  G = w * (2 * pi * eps) / (log(ra/float(ri))) * tand
					  print(f"G' = {G*1E3:.4g}mS/m")
					  a = G*ZL/2
					  print(f"Œ±_G = {a*20/log(10):.4g}dB/m") # bin mir hier nicht sicher ob die umrechnung n√∂tig ist
					  print("‚Äæ‚Äæ‚Äæ‚Äæ‚Äæ‚Äæ‚Äæ‚Äæ‚Äæ‚Äæ‚Äæ‚Äæ‚Äæ‚Äæ‚Äæ‚Äæ")
					  printer.getvalue()
					  ```
						- {{evalparent}}
		- Variante 3)
		  background-color:: green
		  collapsed:: true
		  ![img](../assets/documents/WA_koaxialkabel_bsp_1.webp) ![img](../assets/documents/WA_rechteckhohlleiter_bsp_1.webp)
			- a) Bestimmen Sie einen geeigneten Innenradius $r_i$ des abgebildeten Koaxialkabels f√ºr $Z_L = 50 \mathrm{\Omega}$. Der Au√üenradius sei $r_a = 6.3 \mathrm{mm}$, das verwendete Dielektrikum sei Luft mit $\varepsilon_r = 2.25$.
			  background-color:: green
				- formeln
					- ((6745a3c5-c563-4874-8d5b-50fee6812aea))
				- code
					- ```python
					  pyodide_js.globals.clear();
					  ```
						- {{evalparent}}
					- ```python
					  import pyodide_js
					  await pyodide_js.loadPackage("micropip")
					  import micropip
					  await micropip.install('scipy')
					  from scipy import *
					  from scipy.constants import *
					  from numpy import *
					  await micropip.install('matplotlib')
					  import matplotlib.pyplot as plt
					  import io, base64, sys
					  await micropip.install('sympy')
					  import sympy as sp
					  from sympy.utilities.lambdify import lambdify
					  printer = io.StringIO()
					  sys.stdout = printer
					  
					  # angabe
					  ZL = 50
					  ra = 6.3E-3
					  epsr = 2.25
					  eps = epsr * epsilon_0
					  mur = 1
					  mu = mur * mu_0
					  eta = sqrt(mu/eps)
					  
					  eta_s, ra_s, ri_s = sp.symbols('eta r_a r_i', 
					                                 real=True, 
					                                 positive=True)
					  ZL_s = eta_s/(2*pi) * sp.ln(ra_s / ri_s)
					  
					  eqn = sp.Eq(ZL_s, ZL)
					  sol = sp.solve(eqn, ri_s)
					  ri_s = sol[0]
					  
					  # werte einsetzen
					  ri = (ri_s.subs(ra_s, ra)
					          	.subs(eta_s, eta)).evalf(n=4)
					  
					  print(f"r_i = {ri*1000:.4g}mm")
					  print("‚Äæ‚Äæ‚Äæ‚Äæ‚Äæ‚Äæ‚Äæ‚Äæ‚Äæ‚Äæ‚Äæ‚Äæ‚Äæ")
					  print(f"latex code: {sp.latex(ri_s)}")
					  sp.pprint(ri_s,use_unicode=False)
					  
					  printer.getvalue()
					  ```
						- {{evalparent}}
						- $r_{a} e^{- \frac{314.15926535898}{\eta}}$
			- b) Berechnen Sie die ohmschen Verluste $\alpha_R$ des Kabels f√ºr eine Leitf√§higkeit des Innen- bzw. Au√üenleiters von $\sigma=5.7\cdot10^7\mathrm{S/m}$ bei $10\mathrm{GHz}$ in $\mathrm{dB/m}$.
			  background-color:: green
				- formeln
					- ((674d7759-1d40-46b8-9d39-cbf868cd298e))
					- ((674d7759-4a7e-4220-b396-27bd49ccaa45))
					- ((674de501-a2a9-4e7a-8a81-892354262c7e))
				- code
					- ```python
					  printer.seek(0); printer.truncate(0)
					  sig = 57E6
					  f = 10E9
					  w = 2*pi*f
					  R = (sqrt((w * mu)/(2 * sig))*
					       1 / (2 * pi) * (1 / ri + 1 / ra))
					  print(f"R' = {R:.4g}Œ©/m")
					  
					  alphaR = R/(2*ZL)
					  print(f"alphaR = {alphaR:.4g}Np/m")
					  print(f"alphaR = {alphaR*20/log(10):.4g}dB/m")
					  print("‚Äæ‚Äæ‚Äæ‚Äæ‚Äæ‚Äæ‚Äæ‚Äæ‚Äæ‚Äæ‚Äæ‚Äæ‚Äæ‚Äæ‚Äæ‚Äæ‚Äæ‚Äæ‚Äæ‚Äæ")
					  
					  printer.getvalue()
					  ```
						- {{evalparent}}
			- c) Berechnen Sie die dielektrischen Verluste $\alpha_G$ des Kabels f√ºr ein Dielektrikum mit $\tan\delta = 0.001 \mathrm{dB/m}$ in $\mathrm{dB/m}$.
			  background-color:: green
				- formeln
					- ((674d7759-056e-4bac-998e-f2bccdc83035))
				- code
					- ```python
					  printer.seek(0); printer.truncate(0)
					  
					  tand= 0.001
					  
					  G = w * (2 * pi * eps) / (log(ra/float(ri))) * tand
					  print(f"G' = {G*1E3:.4g}mS/m")
					  a = G*ZL/2
					  print(f"Œ±_G = {a:.4g}dB/m")
					  print("‚Äæ‚Äæ‚Äæ‚Äæ‚Äæ‚Äæ‚Äæ‚Äæ‚Äæ‚Äæ‚Äæ‚Äæ‚Äæ‚Äæ‚Äæ‚Äæ")
					  printer.getvalue()
					  ```
						- {{evalparent}}
			- d) Berechnen Sie mittels der Power-Loss-Method den D√§mpfungskoefÔ¨Åzienten des abgebildeten Rechteckhohlleiters mit den Abmessungen $a = 22.86 \mathrm{mm}$ und $b = 10.16 \mathrm{mm}$ bei $10 \mathrm{GHz}$ (Grundmodus $\mathrm{TE}_{10}$) in $\mathrm{dB/m}$. Erkl√§ren Sie dabei Ihre Vorgehensweise. Das Metall sei durch $\sigma = 5.7 \cdot 10^7 \mathrm{S/m}$ charakterisiert. Bei der gesuchten Ausbreitung in $z$-Richtung lauten die Feldkomponenten: $\\ E_x = 0 \\ E_{y}=-\frac{j\omega\mu}{\pi}a A \sin\left(\frac{\pi}{a}x\right)e^{-j k_{z}z} \\ E_z=0 \\ H_{x}=\frac{j k_{z}}{\pi}a A \sin\left(\frac{\pi}{a}x\right)e^{-j k_{z}z} \\ H_y = 0 \\ H_{z} = A \cos \left( \frac{\pi}{a}x \right) e^{-j k_{z}z}$
			  background-color:: green
				- TODO this
	- Dielektrische Platte #wip
	  background-color:: green
	  collapsed:: true
		- Berechnen Sie die Ausbreitungseigenschaften der $\mathrm{H}_{10}$-√§hnlichen Grundwelle (siehe Rechteckhohlleiter), die von einer in $y$- und $z$-Richtung unbegrenzten und in $x$-Richtung $2d$ dicken dielektrischen Platte (Raum 1) gef√ºhrt wird (Raum 2 ist Luft)!
		  background-color:: green
		  ![img](../assets/documents/WA_dielektrische_platte_bsp_1.webp)
			- a) Finden Sie einen Ansatz f√ºr die Komponenten des elektromagnetischen Feldes in Ausbreitungsrichtung (positive $z$-Richtung) $E_{z1}$, $E_{z2}$, $H_{z1}$ und $H_{z2}$ der die Wellengleichung erf√ºllt und geben Sie die Separationsbedingungen an! Nutzen Sie die Symmetrie der Platte und ber√ºcksichtigen Sie nur $x > ‚àíd$!
			  background-color:: green
			- b) Bestimmen Sie die restlichen Feldkomponenten!
			  background-color:: green
			- c) Gewinnen Sie aus den Stetigkeitsbedingungen an der GrenzÔ¨Ç√§che zwischen Luft und Dielektrikum weitere Beziehungen zur Bestimmung der Ausbreitungskonstanten. Reduzieren Sie die gewonnenen Beziehungen zu einer einzigen transzendenten Gleichung f√ºr die Ausbreitungskonstante in $x$-Richtung ausserhalb der Platte in Abh√§ngigkeit der Frequenz $\omega$!
			  background-color:: green
			- d) Ermitteln Sie eine Gleichung f√ºr die Grenzfrequenz der Grundwelle an. Die Grenzfrequenz ist durch den √úbergang von der gef√ºhrten Welle zur unged√§mpften Abstrahlung in den Raum neben der Platte deÔ¨Åniert!
			  background-color:: green
	- Dielektrischer Wellenleiter
	  background-color:: green
	  collapsed:: true
		- Gegeben sei ein dielektrischer Wellenleiter der Dicke $d = 1\mathrm{cm}$ mit einer relativen Permittivit√§t von $\varepsilon_2 = 2.26$. Oberhalb des Wellenleiters beÔ¨Ånde sich Luft ($\varepsilon_3 = 1$), unterhalb ein idealer Leiter. Es breite sich eine Welle in $z$-Richtung aus!
		  background-color:: green
		  ![img](../assets/documents/WA_dielektrischer_wellenleiter_bsp_1.webp)
			- a) Finden Sie den minimalen Ansatz f√ºr $\mathrm{TE}$-Wellen! Benennen Sie alle Terme!
			  background-color:: green
				- skript
					- ((67508335-6d86-4e15-a41a-550561c07696))
				- formeln
					- $H_{z1}=A_{1}~\mathrm{cos}\left(k_{x1}x\right)e^{-j k_{z}z} \\ H_{z2}=A_{2}~e^{-k_{x2}(x-d)}~e^{-j k_{z}z}$
					  tags:: formel, wellenausbreitung
					  bezeichnung:: ansatz f√ºr die $\mathrm{TE}$-welle in einem ebenen wellenleiter
					  id:: 67508103-1a02-4819-8b68-7d3d9cf8f041
					  collapsed:: true
						- $H_{z1}, H_{z2}$ ... magnetische feldst√§rkekomponente in medium 1 bzw 2 $\mathrm{\left[\frac{A}{m}\right]}$
						- $A_1, A_2$ ... amplitude in medium 1 bzw 2 $\mathrm{\left[\frac{A}{m}\right]}$
						- $k_{x1}, k_{x2}$ ... [[wellenzahl]] in medium 1 bzw 2 $\mathrm{\left[\frac{rad}{m}\right]}$
						- $z$ ... ausbreitungsrichtung $\mathrm{\left[m\right]}$
						- $d$ ... [[eindringtiefe]] $\mathrm{\left[m\right]}$
						- skript
						  collapsed:: true
							- ((675090f8-65ba-412b-8543-a560d7644e48))
				- code
				  id:: 67517609-f23a-458d-a213-d605769b4963
				  collapsed:: true
				- medium 2
					- da in $x$-richtung stehende wellen anzunehmen sind wird $\cos$ oder $\sin$ angestzt. da am metall die randbedingung $E_{tang}$ erf√ºllt sein muss ([link](((67459ac8-e918-4a08-8003-07057ff681d6)))), wird ein $\cos$ angesetzt
				- medium 3
					- in $x$-richtung dissipiert die welle mit einer $e$ potenz
			- b) Berechnen Sie die Separationsbedingungen und berechnen Sie die restlichen Feldkomponenten!
			  background-color:: green
				- formeln
					- ((6750988d-c460-4ec0-8652-1b15a9976b66)) [FS](((674d7759-2ef6-4ef6-9620-b611b833d779)))
					- $k_{x1}^{2}+k_{z}^{2} = k_1^2 = \omega^{2} \varepsilon_{1} \mu_{0} \\ -k_{x2}^{2} + k_{z}^{2} = k_2^2 = \omega^{2} \varepsilon_{2} \mu_{0}$
					  tags:: formel, wip
					  bezeichnung:: separationsbedingung f√ºr [[dielektrische wellenleiter]] [link](((674d7759-0e35-482f-8086-9026be01cd14)))
					  id:: 67509364-eaba-40b7-bcaa-fc7c23e9954a
					  collapsed:: true
						- $-$ ...
						- skript
							- ((67517642-4ec8-4409-ade6-cc8d78118a1e))
					- ((67508103-1a02-4819-8b68-7d3d9cf8f041))
				- code
					- ```python
					  pyodide_js.globals.clear();
					  ```
						- {{evalparent}}
					- ```python
					  import pyodide_js
					  await pyodide_js.loadPackage("micropip")
					  import micropip
					  await micropip.install('scipy')
					  from scipy import *
					  from scipy.constants import *
					  from numpy import *
					  await micropip.install('matplotlib')
					  import matplotlib.pyplot as plt
					  import io, base64, sys
					  await micropip.install('sympy')
					  import sympy as sp
					  from sympy.utilities.lambdify import lambdify
					  from sympy import latex
					  printer = io.StringIO()
					  stdout = sys.stdout
					  sys.stdout = printer
					  
					  A2, kappa2, kx2, ky2, kz, k2, \
					  Ex2, Ey2, Ez2, Hx2, Hy2, Hz2, \
					  x, y, z, w, u = sp.symbols('A_2 Œ∫_2 k_x2 k_y2 k_z k_2 \
					  						    E_x2 E_y2 E_z2 H_x2 H_y2 H_z2 \
					                              x y z œâ Œº', 
					                             real=True)
					  Ez2 = 0
					  Hz2 = A2*sp.cos(kx2*x)*sp.exp(-1j*kz*z)
					  eqn = sp.Eq(k2**2, kx2**2+kz**2)
					  k2 = sp.solve(eqn,k2)[1]
					  eqn = sp.Eq(kappa2**2, k2**2 - kz**2)
					  kappa2 = sp.solve(eqn,kappa2)[1]
					  
					  Ex2 = (-1j / kappa2**2 *
					    	  (
					          kz * sp.diff(Ez2,x) + 
					          w * u * sp.diff(Hz2,y) 
					        )
					  	 )
					  print("######  E_x2  ######")
					  print(f"latex code: {sp.latex(Ex2)}")
					  sp.pprint(Ex2, use_unicode=False)
					  
					  Ey2 = (-1j / kappa2**2 *
					    	  (
					          kz * sp.diff(Ez2,y) + 
					          w * u * sp.diff(Hz2,x) 
					        )
					  	 )
					  print("\n######  E_y2  ######")
					  print(f"latex code: {sp.latex(Ey2)}")
					  sp.pprint(Ey2, use_unicode=False)
					  
					  Hx2 = (-1j / kappa2**2 *
					    	  (
					          kz * sp.diff(Hz2,x) + 
					          w * u * sp.diff(Ez2,y) 
					        )
					  	 )
					  print("\n######  H_x2  ######")
					  print(f"latex code: {sp.latex(Hx2)}")
					  sp.pprint(Hx2, use_unicode=False)
					  
					  Hy2 = (-1j / kappa2**2 *
					    	  (
					          kz * sp.diff(Hz2,y) + 
					          w * u * sp.diff(Ez2,x) 
					        )
					  	 )
					  print("\n######  H_y2  ######")
					  print(f"latex code: {sp.latex(Hy2)}")
					  sp.pprint(Hy2, use_unicode=False)
					  
					  printer.getvalue()
					  ```
						- {{evalparent}}
					- ```python
					  printer.seek(0); printer.truncate(0)
					  
					  A3, kappa3, kx3, ky3, k3, \
					  Ex3, Ey3, Ez3, Hx3, Hy3, Hz3, d = sp.symbols('A_3 Œ∫_3 k_x3 k_y3 k_3 \
					  											E_x3 E_y3 E_z3 H_x3 H_y3 H_z3 d', 
					                                             real=True)
					  Ez3 = 0
					  Hz3 = A3*sp.exp(-kx3*(x-d))*sp.exp(-1j*kz*z)
					  eqn = sp.Eq(k3**2, -kx3**2+kz**2)
					  k3 = sp.solve(eqn,k3)[1]
					  eqn = sp.Eq(kappa3**2, k3**2 - kz**2)
					  kappa3 = sp.solve(eqn,kappa3)[1]
					  
					  Ex3 = (-1j / kappa3**2 *
					    	  (
					          kz * sp.diff(Ez3,x) + 
					          w * u * sp.diff(Hz3,y) 
					        )
					  	 )
					  print("######  E_x3  ######")
					  print(f"latex code: {sp.latex(Ex3)}")
					  sp.pprint(Ex3, use_unicode=False)
					  
					  Ey3 = (-1j / kappa3**2 *
					    	  (
					          kz * sp.diff(Ez3,y) + 
					          w * u * sp.diff(Hz3,x) 
					        )
					  	 )
					  print("\n######  E_y3  ######")
					  print(f"latex code: {sp.latex(Ey3)}")
					  sp.pprint(sp.simplify(Ey3), use_unicode=False)
					  
					  Hx3 = (-1j / kappa3**2 *
					    	  (
					          kz * sp.diff(Hz3,x) + 
					          w * u * sp.diff(Ez3,y) 
					        )
					  	 )
					  print("\n######  H_x3  ######")
					  print(f"latex code: {sp.latex(Hx3)}")
					  sp.pprint(sp.simplify(Hx3), use_unicode=False)
					  
					  Hy3 = (-1j / kappa3**2 *
					    	  (
					          kz * sp.diff(Hz3,y) + 
					          w * u * sp.diff(Ez3,x) 
					        )
					  	 )
					  print("\n######  H_y3  ######")
					  print(f"latex code: {sp.latex(Hy3)}")
					  sp.pprint(Hy3, use_unicode=False)
					  
					  printer.getvalue()
					  ```
						- {{evalparent}}
			- c) Finden Sie die Randbedingungen!
			  background-color:: green
				- formeln
					- ((67459ac8-e918-4a08-8003-07057ff681d6))
					- $E_{\mathrm{tang1}} = E_{\mathrm{tang2}} \\ H_{\mathrm{tang1}} = H_{\mathrm{tang2}}$
					  tags:: formel
					  bezeichnung:: randbedingungen f√ºr den √ºbergang einer welle an einer grenzfl√§che zwischen dielektrika
						- $E_{\mathrm{tang1}},E_{\mathrm{tang2}}$ ... tangential komponente des [[elektrischen feldes]] im medium 1 bzw 2 $\mathrm{\left[\frac{V}{m}\right]}$
						- $H_{\mathrm{tang1}},H_{\mathrm{tang2}}$ ... tangential komponente des [[magnetischen feldes]] im medium 1 bzw 2 $\mathrm{\left[\frac{A}{m}\right]}$
						- skript
						  collapsed:: true
							- ((6751d667-3181-4b73-87e6-9e864f549a9c))
							- ((6751d67e-65ca-4200-97c6-6e1dbfc841a2))
					- ((67508103-1a02-4819-8b68-7d3d9cf8f041))
				- code
					- ```python
					  printer.seek(0); printer.truncate(0)
					  # randbedingung f√ºr x = d
					  Ety2, Ety3, Hty2, Hty3, \
					  Etz2, Etz3, Htz2, Htz3, \
					  A2, A3, kx2, kx3, dd = sp.symbols('E_tang_x2 E_tang_x3 H_tang_x2 H_tang_x_3 \
					  							      E_tang_z2 E_tang_z3 H_tang_z2 H_tang_z3 \
					                                    A_2 A_3 k_x2 k_x3 d', 
					                                    real=True)
					  Etz2 = Etz3 # da TE welle = 0
					  Hty2 = Hty3 # oben berechnet = 0
					  
					  Ety2 = Ey2.subs(x,dd)
					  Ety3 = Ey3.subs(x,dd)
					  
					  Htz2 = Hz2.subs(x,dd)
					  Htz3 = Hz3.subs(x,dd)
					  
					  print("######  Ey  ######")
					  eqn = sp.Eq(Ety2,Ety3)
					  rBEy = sp.solve(eqn, A3)[A3]
					  print(f"latex code: {sp.latex(sp.trigsimp(rBEy))}")
					  sp.pprint(sp.trigsimp(rBEy), use_unicode=False)
					  
					  print("\n######  Hz  ######")
					  eqn = sp.Eq(Htz2,Htz3)
					  rBHz = sp.solve(eqn, A3)[A3]
					  eqn = sp.Eq(rBEy, rBHz)
					  rBHz = rBEy-rBHz
					  print(f"latex code: {sp.latex(sp.simplify(rBHz))}")
					  sp.pprint(sp.simplify(rBHz), use_unicode=False)
					  
					  printer.getvalue()
					  ```
						- {{evalparent}}
			- d) Bestimmen Sie die Dispersionsgleichung und die Grenzfrequenzen der ersten drei Moden! Skizzieren Sie das Dispersionsdiagramm!
			  background-color:: green
				- skript
				  collapsed:: true
					- ((675330c9-5692-476c-ab43-c0f8c7614a54))
				- formeln
					- ((674d7759-f065-41be-aa7b-2bb81097b152))
					- ((67509364-eaba-40b7-bcaa-fc7c23e9954a))
				- code
					- ```python
					  printer.seek(0); printer.truncate(0)
					  d_n = 1E-2
					  epsr2 = 2.26
					  epsr3 = 1
					  
					  m, w, k_tot, kz2, kz3 = sp.symbols('m w k_tot kz2 kz3', 
					                  			positive=True, 
					                  			real=True)
					  
					  eqn = sp.Eq(kx2**2 + kz**2, w**2 * epsr2 *mu_0)
					  kx2_t = sp.solve(eqn, kx2)[1]
					  kz2 = sp.solve(kx2_t)[1][kz]
					  sp.pprint(kz2, use_unicode=False)
					  kz2_n = lambdify(w, kz2)
					  
					  eqn = sp.Eq(-kx3**2 + kz**2, w**2 * epsr3 *mu_0)
					  kx3_t = sp.solve(eqn, kx3)[1]
					  kz3 = sp.solve(kx3_t)[1][kz]
					  sp.pprint(kz3, use_unicode=False)
					  kz3_n = lambdify(w, kz3)
					  
					  wcm = (
					    	    ((2 * m - 1) * pi) /
					          (2 * d_n * sp.sqrt(epsilon_0 * mu_0 * (epsr2 - epsr3)))
					        )
					  
					  fc1 = wcm.subs(m,1).evalf() / (2 * pi)
					  print(f"fc1 = {fc1/1E9:.4g}GHz")
					  fc2 = wcm.subs(m,2).evalf() / (2 * pi)
					  print(f"fc2 = {fc2/1E9:.4g}GHz")
					  fc3 = wcm.subs(m,3).evalf() / (2 * pi)
					  print(f"fc3 = {fc3/1E9:.4g}GHz")
					  printer.getvalue()
					  ```
						- {{evalparent}}
					- ```python
					  printer.seek(0); printer.truncate(0)
					  
					  w_n = linspace(0, 
					                 int(max(fc1,fc2,fc3)*1.2*(2*pi)), 
					                 1000)
					  
					  # Create the plot
					  plt.clf()
					  plt.plot(w_n, kz2_n(w_n), label='k_2')
					  plt.plot(w_n, kz3_n(w_n), label= 'k_3')
					  plt.plot([2*pi*fc1, 2*pi*fc1],
					           [0, kz3_n(2*pi*fc1)],
					           color='red',
					           linestyle='--',
					           label="fc1")
					  plt.scatter([2*pi*fc1, 2*pi*fc1],
					              [kz3_n(2*pi*fc1), kz3_n(2*pi*fc1)], 
					              color='red', zorder=5)
					  plt.plot([2*pi*fc2, 2*pi*fc2],
					           [0, kz3_n(2*pi*fc2)],
					           color='red',
					           linestyle='--',
					           label="fc2")
					  plt.scatter([2*pi*fc2, 2*pi*fc2],
					              [kz3_n(2*pi*fc2), kz3_n(2*pi*fc2)], 
					              color='red', zorder=5)
					  plt.plot([2*pi*fc3, 2*pi*fc3],
					           [0, kz3_n(2*pi*fc3)],
					           color='red',
					           linestyle='--',
					           label="fc3")
					  plt.scatter([2*pi*fc3, 2*pi*fc3],
					              [kz3_n(2*pi*fc3), kz3_n(2*pi*fc3)], 
					              color='red', zorder=5)
					  plt.xlabel('œâ')  # Label the x-axis
					  plt.ylabel('k')  # Label the y-axis
					  plt.grid(True)  # Add a grid
					  plt.legend()
					  buf = io.BytesIO()
					  plt.savefig(buf, format = 'png')
					  buf.seek(0)
					  png = 'data:image/png;base64,' + base64.b64encode(buf.read()).decode('UTF-8')
					  buf.close()
					  png
					  printer.getvalue()
					  ```
						- {{evalparent}}
			- [üìö 2024-12-05 11h58m.xopp](../assets/documents/2024-12-05 11h58m.xopp)
			- ![üìö 2024-12-05 11h58m_annotated.pdf](../assets/documents/2024-12-05 11h58m_annotated.pdf)
	- Parallelplattenleitung
	  background-color:: green
		- Es soll die Ausbreitungsf√§higkeit des $\mathrm{TEM}$ Modus in $z$-Richtung auf dem abgebildeten Parallelplattenleiter (mit $\varepsilon_r = 3.5$) untersucht werden.
		  background-color:: green
		  id:: 67507618-c8e1-4f6f-88bc-e228e47f184d
		  Hinweis: $\varepsilon_0 = \mathrm{8.854¬∑ 10^{‚àí12}~As/Vm}$, $¬µ0 = \mathrm{4œÄ ¬∑ 10^{‚àí7}~Vs/Am}$.
		  ![img](../assets/documents/WA_parallelplattenleitung_bsp_1.webp)
			- a) Berechnen Sie die Komponenten der gefragten Moden, Ô¨Ånden Sie einen Ansatz der die Wellengleichung erf√ºllt, ermitteln Sie die Separationsbedingungen und passen Sie an den Rand an! Verwenden Sie dabei die N√§herung $w \gg d$. Welche Komponenten verschwinden?
			  background-color:: green
				- formeln
					- ((673e3379-7ae8-425b-bf90-a176d50f983b))
					- ((6735b379-187a-4654-8126-efd8a322477b))
					- ((67403e6c-c82c-4ada-a67e-ba11b41ebcc8)) [FS](((67404a07-268a-4632-b86f-c136cdfaf0eb)))
				- code
			- b) Berechnen Sie den Mediumswiderstand, den Leitungswellenwiderstand und die Grenzfrequenz des gefragten Modus f√ºr $w = 12 \mathrm{mm}$, $d = 3 \mathrm{mm}$! Geben Sie alle zur Berechnung notwendigen Schritte an!
			  background-color:: green
				- formeln
				- code
					-
			- c) Berechnen Sie mittels der Power Loss Method den D√§mpfungskoeÔ¨Ézienten f√ºr den gefragten Modus in $\mathrm{dB/m}$. Das Metall sei durch $\sigma_{Cu} = 48 \cdot 10^6 \mathrm{S/m}$ charakterisiert, die Frequenz sei $7 \mathrm{GHz}$. Geben Sie alle zur Berechnung notwendigen Schritte an!
			  background-color:: green
			- d) Zeichnen Sie die tats√§chlichen Feldbilder ohne Verwendung der N√§herung $w \gg d$ in zwei Ansichten! Welche Wellentypen sind prinzipiell auf dieser Leitung ausbreitungsf√§hig?
			  background-color:: green
				- ![img](../assets/documents/WA_parallelplattenleitung_feldbild_illustration_1.webp) ![img](../assets/documents/WA_parallelplattenleitung_feldbild_illustration_2.webp)
- ## flashcards
  collapsed:: true
	- ### index
		- query-table:: true
		  collapsed:: true
		  #+BEGIN_QUERY
		  {
		  :title [:b "all flashcards"]
		  :query [:find (pull ?block [*])
		  :where
		  [?block :block/content ?blockcontent]
		  [?block :block/page ?page]
		  [?page :block/name ?pagename]
		  [?block :block/path-refs [:block/name "flashcard"]]
		  ( or
		  (property ?block :deck "Uni::Automatisierungstechnik_Theorie")
		  (property ?block :deck "Uni::Mathematik_Theorie")
		  )
		  ( not
		  (?page :page/name "templates-uni")
		  )
		  ]
		  }
		  #+END_QUERY
		- query-table:: true
		  query-properties:: [:block :tags]
		  collapsed:: true
		  #+BEGIN_QUERY
		  {
		  :title [:b "all flashcards defined here"]
		  :query [:find (pull ?block [*])
		  :where
		  [?block :block/content ?blockcontent]
		  [?block :block/page ?page]
		  [?page :block/name ?pagename]
		  [?block :block/path-refs [:block/name "flashcard"]]
		  ( or
		  (property ?block :deck "Uni::Automatisierungstechnik_Theorie")
		  (property ?block :deck "Uni::Mathematik_Theorie")
		  )
		  [?page :page/name "automatisierungstechnik"]
		  ]
		  }
		  #+END_QUERY
	- wie lautet der ansatz f√ºr die $\mathrm{TE}$-welle in einem ebenen wellenleiter
	  deck:: Uni::Wellenausbreitung_Theorie
	  tags:: flashcard
	  id:: 675179b4-cf9b-4790-9496-3e14e469dcc8
		- ((67508103-1a02-4819-8b68-7d3d9cf8f041))
	- wie lautet die separationsbedingung fpr [[dielektrische wellenleiter]]?
	  deck:: Uni::Wellenausbreitung_Theorie
	  tags:: flashcard
	  id:: 67517953-6b7e-450b-a047-4e6dd56f023c
		- ((67517609-f23a-458d-a213-d605769b4963))
	- wof√ºr stehen $\mathrm{TM}$, $\mathrm{TE}$ und $\mathrm{TEM}$? 
	  id:: 6736247d-67c9-4c4e-ba0e-2d9d5c1a369d
	  deck:: Uni::Wellenausbreitung_Theorie
	  tags:: flashcard
		- $\mathrm{TM}$
			- ***T***ransversal ***M***agnetische Welle
			- $H_z=0$ also der magnetische feldst√§rke vektor ist komplett transversal ($90¬∞$) zur ausbreitungsrichtung (hier $z$)
		- $\mathrm{TE}$
			- ***T***ransversal ***E***lektrische Welle
			- $E_z=0$ also der elektrische feldst√§rke vektor ist komplett transversal ($90¬∞$) zur ausbreitungsrichtung (hier $z$)
		- $\mathrm{TEM}$
			- ***T***ransversal ***E***lektro-***M***agnetische Welle
			- $H_z = E_z = 0$ also der magnetische und elektrische feldst√§rke vektor ist komplett transversal ($90¬∞$) zur ausbreitungsrichtung (hier $z$)
	- wie teilt sich die leistung einer welle bei zitkular polarisierten welle auf?
	  deck:: Uni::Wellenausbreitung_Theorie
	  tags:: flashcard
	  id:: 674d7841-1b87-4fd4-b726-5ffaf53b1838
	  collapsed:: true
		- die TE und TM Wellen haben die gleiche leistung
		- ((673b6e21-b584-4162-9dee-58697f01a4bb))
	- welcher faktor ($\Gamma_{\mathrm{TM}},~\Gamma_{\mathrm{TE}}, ~T_{\mathrm{TM}},~T_{\mathrm{TE}}$) ist unter einfall des [[brewster winkels]] gleich $0$?
	  deck:: Uni::Wellenausbreitung_Theorie
	  tags:: flashcard
	  id:: 674d7841-5b07-4712-a098-3e0768f96c58
		- $\Gamma_{\mathrm{TM}}$
	- was beschreibt eine mode?
	  deck:: Uni::Wellenausbreitung_Theorie
	  tags:: flashcard
	  id:: 674d7841-6fa3-4dae-921b-09d19b78642d
		- eine mode beschreibt die gestalt der felder
	- was ist die g√ºnstigste form eines quaderf√∂rmigen hohlraum resonators?
	  deck:: Uni::Wellenausbreitung_Theorie
	  tags:: flashcard
	  id:: 674d7841-95a7-4f17-ada9-bdfbf1975442
		- wenn man das gr√∂√üte volumen bei kleinstm√∂glicher oberfl√§che hat, also $a=b=c$
	- was sind die eigenschaften harmonischer funktionen 
	  deck:: Uni::Wellenausbreitung_Theorie
	  tags:: flashcard
		- | $h(k_z z)$ | Nullstellen Polstellen | besondere Werte f√ºr $k_z = \beta - j\alpha$ | Darstellung f√ºr verschiedene Werte von $k_z$ | physikalische Bedeutung | 
		   | $e^{-jk_zz}$ | $k_zz ‚Üí - j \infty$<br /><br />$k_zz‚Üíj\infty$ | $k_z$ reell <br />$k_z$ imagin√§r <br />$k_z$ komplex | $e^{-j\beta z} \\ e^{-\alpha z} \\ e^{-j\alpha z} e^{-j\beta z}$ | Wanderwelle in $+z$ <br />evaneszentes Feld, abklingend <br />ged√§mpfte Welle | 
		   | $e^{jk_zz}$ | $k_zz ‚Üí j \infty$<br /><br />$k_zz ‚Üí - j\infty$ | $k_z$ reell <br />$k_z$ imagin√§r <br />$k_z$ komplex | $e^{+j\beta z} \\ e^{+\alpha z} \\ e^{+j\alpha z} e^{-j\beta z}$ | Wanderwelle in $-z$ <br />evaneszentes Feld, anklingend <br />ged√§mpfte Welle | 
		   | $\sin (k_{z2})$ | $k_zz ‚Üí n\pi$<br /><br />$k_zz‚Üí\pm j\infty$ | $k_z$ reell <br />$k_z$ imagin√§r <br />$k_z$ komplex | $\sin(\beta z) \\ -j\sinh(\alpha z) \\ \cos(\beta z)\cosh(\alpha z) + j \sin(\beta z) \sinh(\alpha z)$ | stehende Welle <br />zwei evaneszente Felder <br />gegenlaufige ged√§mpfte Wellen | 
		   | $\cos (k_zz)$ | $k_zz ‚Üí (n+\frac12)\pi$<br /><br />$k_zz ‚Üí \pm j\infty$ | $k_z$ reell <br />$k_z$ imagin√§r <br />$k_z$ komplex | $\cos(\beta z) \\ \cosh(\alpha z) \\ \cos(\beta z)\cosh(\alpha z) + j \sin(\beta z) \sinh(\alpha z)$ | stehende Welle <br />zwei evaneszente Felder <br />gegenl√§ufige ged√§mpfte Wellen |